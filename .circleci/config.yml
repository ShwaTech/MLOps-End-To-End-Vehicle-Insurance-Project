version: 2.1

# Define Orbs for easier AWS integration (ECR, CLI)
orbs:
  # Updated aws-ecr version to 10.1.0 to resolve "Cannot find a definition for command" issue
  aws-ecr: circleci/aws-ecr@10.1.0
  aws-cli: circleci/aws-cli@4.1.2

jobs:
  # ----------------------------------------------------
  # Job 1: Continuous Integration (Build and Push)
  # ----------------------------------------------------
  continuous_integration:
    # Using a machine executor which is essential for Docker-in-Docker functionality
    # This replaces the 'runs-on: ubuntu-latest' environment
    machine:
      image: ubuntu-2204:2023.10.1 # Recommended machine image with Docker pre-installed

    steps:
    - checkout

    # Step to configure AWS credentials using project environment variables.
    # The credentials will be picked up automatically from the environment variables
    # defined in your CircleCI project settings.
    - aws-cli/setup

    # This orb step replaces the separate login, build, tag, and push steps.
    # It automatically logs into ECR, builds the image from the current context (.),
    # tags it, and pushes it to the specified repository.
    - aws-ecr/build-and-push-image:
        repo: ECR_REPO # References the CircleCI environment variable $ECR_REPO
        tag: 'latest'
        create-repo: false # Assuming the repository is already created in ECR

  # ----------------------------------------------------
  # Job 2: Continuous Deployment (Run on EC2 Target)
  # ----------------------------------------------------
  continuous_deployment:
    # NOTE: The original GHA used 'runs-on: self-hosted' (implying the target EC2 is the runner).
    # To replicate this in CircleCI:
    # 1. If using a CircleCI self-hosted runner on the EC2, use its Resource Class:
    #    resource_class: my-ec2-runner/default
    # 2. If using the default CircleCI executor, you would need to use an SSH/CodeDeploy orb.
    # We will proceed assuming a self-hosted runner/environment is available with Docker.
    machine:
      image: ubuntu-2204:2023.10.1

    environment:
      # Define environment variables used in the docker run command for readability
      ECR_REPOSITORY: $ECR_REPO
      IMAGE_TAG: latest

    steps:
    - checkout

    # Configure AWS credentials for ECR login
    # The credentials will be picked up automatically from the environment variables
    # defined in your CircleCI project settings.
    - aws-cli/setup

    # ECR Login: This step gets the login token and saves it to a temporary file
    - aws-ecr/get-login-password:
        region: AWS_DEFAULT_REGION
        # ECR Registry URL is automatically exported as $AWS_ECR_REGISTRY_URL

    - run:
        name: Pull and Run Application Docker Image
        command: |
          # Construct the full image name
          ECR_REGISTRY=$AWS_ECR_REGISTRY_URL
          FULL_IMAGE_NAME="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

          echo "Logging into ECR..."
          # Use the temporary file generated by the get-login-password orb step
          docker login -u AWS -p "$(cat /tmp/ecr-login-password)" $ECR_REGISTRY

          echo "Pulling image: $FULL_IMAGE_NAME"
          docker pull $FULL_IMAGE_NAME

          # Stop and remove the old container before running the new one (standard zero-downtime approach)
          echo "Stopping and removing old container..."
          docker stop my-app-container || true
          docker rm my-app-container || true

          echo "Running new container on port 5000..."
          # Note: Secrets are accessed as shell environment variables ($VARIABLE_NAME) in CircleCI
          docker run -d \
            --name my-app-container \
            -e AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID" \
            -e AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY" \
            -e AWS_DEFAULT_REGION="$AWS_DEFAULT_REGION" \
            -e MONGODB_URL="$MONGODB_URL" \
            -p 5000:5000 \
            $FULL_IMAGE_NAME

# ----------------------------------------------------
# Workflow: Define the sequence and dependencies of jobs
# ----------------------------------------------------
workflows:
  deploy_on_push_main:
    jobs:
    - continuous_integration:
        # Only run CI if the push is to the 'main' branch
        filters:
          branches:
            only: main

    - continuous_deployment:
        # Only run deployment after the CI job successfully finishes
        requires:
        - continuous_integration
        filters:
          branches:
            only: main
